FORTH JVM
=========

Java Virtual Machine
--------------------

### Architecture

The Java Virtual Machine (JVM) is a stack machine.

### Instruction Set

The JVM instruction set consist of about 200 instruction. Their opcodes are encoded as 8 bit 
values.

### `Class` File

The JVM uses socalled `class` files to store machine code as well as constants, etc..

### Constant Pool

JVM heavily uses the constant pool.

### JVM stack

Each thread consists of a JVM stack. It is used to store frames for methods. The 
specification does not require the JVM stack to be implemented in a contiguous memory area.

### Frames

Frames are used to store local variables, operant stacks, for dynamic linking and other purposes. 
Frames may be heap allocated ([JVMStacks][]). The frame also contains a pointer to the previous 
frame.

### Operant Stack

Conceptually the operant stack is part of the current frame. In Forth JVM the Forth stack is used
for operants were as other frame data (local variables, previous frame pointer, etc.) are 
stored on the heap.

Core
----

### Threading Technique `jvm_next`  

The main part of Forth JVM is the socalled _NEXT routine_. It repeatedly performes the following 
tasks:

1. load the next instruction
2. increment the instruction pointer (`ip`)
3. execute the instruction

There are different ways how this can be done ([ThreadedCode][]). In the current implementation of 
the NEXT routine the socalled _call threading_ technique is used. The main disadvantage is that 
(indirect) calls are used instead of indirect jumps. If jumps are used one next cycle consists of 
the following steps:

1. load instruction and increment `ip`
2. jump to the address of the implementation of the instruction
3. perform instruction code
4. jump back to 1.

If call instead of jumps are used the following steps are performed:

1. load instruction and increment `ip`
2. call the subrouting that contains the implementation of the instruction
3. perform instruction code
4. return from the call
5. jump back to 1.

Even worse than the fact that there is one more step is that call-return creates and destroys 
a new stack frame what decreases performance dramatically. 
*FIXME:** is this really the case in forth?


### Lookup Table

The lookup table is an array of 256 cells. Each cell stores an _execution token_. The offset 
corresponds to the opcode of the JVM e.g. at the offset 0x10 the execution token for the JVM 
instruction `bipush` is stored.

TODO
----

- method frames/local variables
- find a better solution for terminating a program (catch special exceptions)
- Java Standard APIs. Somehow we must support at least some standard API calls 
  (System.out.println(String) would be nice)
- native code calls?!
- threads? multiple pcs?!

Ideas
-----

- use jumps instead of calles (call threading)
- just in time compilation? replace opcode with execution token of the instruction?
- constant pool: wordlist migth be useful
- somehow abuse the (g)forth kernel to execute next?!

Known Problems
--------------

- much too much...
- not even close to something usable...

References
----------

- [JVMspec][]: The Java&trade; Virtual Machine Specification
- [ClassFile][]: The `class` File Format
- [ThreadedCode][]: Threaded Code

[JVMspec]: http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html 
[JVMstacks]: http://java.sun.com/docs/books/jvms/second_edition/html/Overview.doc.html#30934
[ClassFile]: http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html
[ThreadedCode]: http://www.complang.tuwien.ac.at/forth/threaded-code.html

